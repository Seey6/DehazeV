import os
import math

# ==============================================================================
# 1. 配置区域 (Configuration)
# ==============================================================================

def formula_inv_A(addr):
    """
    LUT_INV_A: 用于计算 H/A
    输入: A (Q8.0, 范围 0-255)
    输出: Q2.8 格式的定标因子 -> round(4096 / A)
    逻辑: (H * Output) >> 4 = H/A (Q2.8)
    [cite_start]论文参考: A >= 100 [cite: 222]
    """
    if addr < 1: return 255 # 防止除零
    
    # 公式: 4096 / addr
    val = (1 << 12) / addr
    return int(round(val))

def formula_inv_khn(addr):
    """
    LUT_KHN: 用于计算 1/KHn
    输入: KHn (Q3.8, 11位, addr代表数值 addr/256)
    输出: Q4.8 格式 -> round(2^16 / addr)
    逻辑: 1 / (addr/256) * 256 = 65536 / addr
    """
    if addr == 0: return 4095 # 防止除零，返回 Q4.8 最大值
    
    # 公式: 65536 / addr
    val = (1 << 12) / addr
    return int(round(val))

def formula_inv_t(addr):
    """
    LUT_INV_12: 用于计算 1/t (透射率倒数)
    输入: Denominator (Q0.12, 12位, addr代表数值 addr/4096)
    输出: Q4.12 格式 -> round(2^24 / addr)
    逻辑: 1 / (addr/4096) * 4096 = 16,777,216 / addr
    """
    if addr == 0: return 1<<12 # 防止除零，返回 Q4.12 最大值 (约15.99)
    
    # 公式: 2^24 / addr
    val = (1 << 12) / addr
    return int(round(val))

# ------------------------------------------------------------------------------
# 模块定义列表
# ------------------------------------------------------------------------------
lut_configs = [
    {
        "name": "lut_inv_A",
        "addr_width": 8,
        "data_width": 8,  # 虽然有效位只需6位，但用8位对齐更通用
        "formula": formula_inv_A,
        "desc": "Calculates 4096/A for Atmospheric Light Normalization"
    },
    {
        "name": "lut_khn",
        "addr_width": 11,
        "data_width": 12, # Q4.8
        "formula": formula_inv_khn,
        "desc": "Calculates 1/KHn (Q3.8 Input -> Q4.8 Output)"
    },
    {
        "name": "lut_inv12",
        "addr_width": 12,
        "data_width": 12, # Q4.8 (支持 >1.0 的倒数)
        "formula": formula_inv_t,
        "desc": "Calculates 1/Denominator (Q0.12 Input -> Q4.12 Output)"
    }
]

# ==============================================================================
# 2. 生成核心逻辑 (Generator Core)
# ==============================================================================

def generate_verilog_file(config):
    name = config["name"]
    addr_w = config["addr_width"]
    data_w = config["data_width"]
    formula = config["formula"]
    desc = config["desc"]
    
    filename = f"rtl/{name}.v"
    depth = 1 << addr_w
    max_data_val = (1 << data_w) - 1
    
    print(f"Generating {filename} (Depth: {depth}, Data Width: {data_w})...")
    
    with open(filename, "w") as f:
        # Header
        f.write(f"// Generated by Python Script (gen_all_luts.py)\n")
        f.write(f"// Module: {name}\n")
        f.write(f"// Description: {desc}\n")
        f.write(f"// Width: {addr_w}-bit In -> {data_w}-bit Out\n\n")
        
        # Attribute for Block RAM inference
        f.write(f"(* rom_style = \"block\" *)\n")
        f.write(f"module {name} (\n")
        f.write(f"    input wire clk, // Clock included for Block RAM timing\n")
        f.write(f"    input wire [{addr_w-1}:0] addr,\n")
        f.write(f"    output reg [{data_w-1}:0] data\n")
        f.write(f");\n\n")
        
        # Logic
        f.write(f"    always @(posedge clk) begin\n")
        f.write(f"        case (addr)\n")
        
        # Generate LUT content
        for i in range(depth):
            # Calculate value
            raw_val = formula(i)
            
            # Clamp value to max width (Safety)
            if raw_val > max_data_val:
                val = max_data_val
            elif raw_val < 0:
                val = 0
            else:
                val = raw_val
                
            # Write line
            f.write(f"            {addr_w}'d{i}: data <= {data_w}'d{val};\n")
        
        f.write(f"            default: data <= {data_w}'d0;\n")
        f.write(f"        endcase\n")
        f.write(f"    end\n\n")
        f.write(f"endmodule\n")

# ==============================================================================
# 3. 主执行入口 (Main)
# ==============================================================================

if __name__ == "__main__":
    for conf in lut_configs:
        generate_verilog_file(conf)
    print("All LUT modules generated successfully.")